"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Pipedrive API v1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Configuration = exports.OAuth2Configuration = void 0;
const axios_1 = __importDefault(require("axios"));
const qs_1 = require("qs");
const base_1 = require("./base");
class OAuth2Configuration {
    constructor(params) {
        this.basePath = "";
        this.axios = axios_1.default.create();
        this.accessToken = null;
        this.refreshToken = null;
        this.scope = null;
        this.expiresIn = 0; // expiration value in seconds sent by the OAuth server.
        this.expiresAt = 0; // expiration time as number of milliseconds elapsed since January 1, 1970 00:00:00 UTC.
        this.getAccessToken = () => __awaiter(this, void 0, void 0, function* () {
            if (this.shouldRefreshToken()) {
                const newToken = yield this.tokenRefresh();
                this.updateToken(newToken);
                return newToken.access_token;
            }
            return this.accessToken;
        });
        this.shouldRefreshToken = () => {
            return this.expiresAt && Date.now() > this.expiresAt;
        };
        /**
         * Authorizes the authorization code sent by the server and returns OAuth 2 token.
         * @param {String} code The authorization code sent by the OAuth server.
         * @returns {Object} The OAuth 2 token.
         */
        this.authorize = (code) => __awaiter(this, void 0, void 0, function* () {
            if (!code) {
                throw new Error("Authorization failed. Authorization code is not set.");
            }
            const authorizationUrl = `${this.host}/oauth/token`;
            const clientIdAndSecretInBase64 = Buffer.from(`${this.clientId}:${this.clientSecret}`).toString("base64");
            const response = yield this.axios.post(authorizationUrl, (0, qs_1.stringify)({
                code,
                redirect_uri: this.redirectUri,
                grant_type: "authorization_code",
            }), {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    Authorization: `Basic ${clientIdAndSecretInBase64}`,
                },
            });
            this.updateToken(response);
            return response;
        });
        this.tokenRefresh = () => __awaiter(this, void 0, void 0, function* () {
            const refreshUrl = `${this.host}/oauth/token`;
            const clientIdAndSecretInBase64 = Buffer.from(`${this.clientId}:${this.clientSecret}`).toString("base64");
            const response = yield this.axios.post(refreshUrl, (0, qs_1.stringify)({
                refresh_token: this.refreshToken,
                grant_type: "refresh_token",
            }), {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    Authorization: `Basic ${clientIdAndSecretInBase64}`,
                },
            });
            this.updateToken(response);
            return response;
        });
        /*
         * Updates the ApiClient OAuth 2 authentication properties and invokes the token update callback if it is set.
         * Besides extracting all the values from the provided OAuth 2 token,
         * the expiration time of access token is calculated and set as expiresAt property.
         * @param {Object} token The OAuth 2 token got from the OAuth server.
         */
        this.updateToken = (token) => {
            var _a;
            if (!token) {
                return null;
            }
            if (token.access_token) {
                this.accessToken = token.access_token;
            }
            if (token.refresh_token) {
                this.refreshToken = token.refresh_token;
            }
            if (token.expires_in) {
                this.expiresIn = token.expires_in;
                this.expiresAt = Date.now() + token.expires_in * 1000;
            }
            if (token.scope) {
                this.scope = token.scope;
            }
            if (token.api_domain) {
                this.basePath = `${token.api_domain}/api/v1`;
            }
            (_a = this.onTokenUpdate) === null || _a === void 0 ? void 0 : _a.call(this, token);
            return token;
        };
        this.validateParam = (params, key) => {
            if (!params[key]) {
                throw new Error(`OAuth 2 property ${key} is not set.`);
            }
            return params[key];
        };
        this.clientId = this.validateParam(params, 'clientId');
        this.clientSecret = this.validateParam(params, 'clientSecret');
        this.redirectUri = this.validateParam(params, 'redirectUri');
        this.host = params.host || "https://oauth.pipedrive.com";
        const basePath = params.host || "https://api.pipedrive.com";
        this.basePath = `${basePath}/api/v1`;
        this.axios.interceptors.response.use(base_1.responseInterceptor, base_1.errorInterceptor);
        this.axios.interceptors.request.use(base_1.versionInterceptor);
    }
    get authorizationUrl() {
        return `${this.host}/oauth/authorize?client_id=${this.clientId}&redirect_uri=${encodeURIComponent(this.redirectUri)}`;
    }
    /**
        * Revoke Refresh Token aka marking an app uninstalled or revoke the Access Token.
        * @param {String} tokenTypeHint values can be: 'access_token' or 'refresh_token'.
    */
    revokeToken(tokenTypeHint) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = tokenTypeHint === 'refresh_token'
                ? this.refreshToken : encodeURIComponent(this.accessToken);
            const clientId = this.clientId;
            const clientSecret = this.clientSecret;
            const revokeUrl = `${this.host}/oauth/revoke?`;
            const clientIdAndSecretInBase64 = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
            const response = yield this.axios.post(revokeUrl, (0, qs_1.stringify)({
                token,
                token_type_hint: tokenTypeHint
            }), {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    'Authorization': `Basic ${clientIdAndSecretInBase64}`,
                }
            });
            return response;
        });
    }
}
exports.OAuth2Configuration = OAuth2Configuration;
class Configuration {
    constructor(param) {
        this.apiKey = param.apiKey;
        this.accessToken = param.accessToken;
        this.formDataCtor = param.formDataCtor;
        this.basePath = param.basePath;
        /** Values either not supported or set by the packaged already **/
        this.username = undefined;
        this.password = undefined;
        this.baseOptions = undefined;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}
exports.Configuration = Configuration;
