"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Pipedrive API v1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequiredError = exports.BaseAPI = exports.errorInterceptor = exports.responseInterceptor = exports.versionInterceptor = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;
const axios_1 = __importDefault(require("axios"));
const path_1 = require("path");
const fs_1 = require("fs");
exports.BASE_PATH = "https://api.pipedrive.com/v1".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
const searchForPackageJson = (startPath) => {
    const filePath = (0, path_1.join)(startPath, 'package.json');
    if ((0, fs_1.existsSync)(filePath)) {
        return filePath;
    }
    const parentDir = (0, path_1.dirname)(startPath);
    // Stop if we've reached the root directory
    if (parentDir.endsWith('/pipedrive') || parentDir === startPath) {
        return null;
    }
    return searchForPackageJson(parentDir);
};
const versionInterceptor = (config) => __awaiter(void 0, void 0, void 0, function* () {
    let version;
    try {
        const path = searchForPackageJson(__dirname);
        version = path ? require(path).version : '22.x';
    }
    catch (error) {
        version = '22.x';
    }
    config.headers['User-Agent'] = `Pipedrive-SDK-Javascript-${version}`;
    return config;
});
exports.versionInterceptor = versionInterceptor;
const responseInterceptor = (response) => {
    return (response === null || response === void 0 ? void 0 : response.data) ? response.data : response;
};
exports.responseInterceptor = responseInterceptor;
const errorInterceptor = (error) => {
    if (error.response && error.response.data) {
        return Promise.reject(error.response.data);
    }
    return Promise.reject(error);
};
exports.errorInterceptor = errorInterceptor;
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration) {
        this.basePath = exports.BASE_PATH;
        this.axios = axios_1.default.create();
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
        this.axios.interceptors.response.use(exports.responseInterceptor, exports.errorInterceptor);
        this.axios.interceptors.request.use(exports.versionInterceptor);
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
